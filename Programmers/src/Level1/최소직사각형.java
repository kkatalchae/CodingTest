package Level1;

import java.util.Arrays;

public class 최소직사각형 {

    /*
    문제 설명

    명함 지갑을 만드는 회사에서 지갑의 크기를 정하려고 합니다.
    다양한 모양과 크기의 명함들을 모두 수납할 수 있으면서, 작아서 들고 다니기 편한 지갑을 만들어야 합니다.
    이러한 요건을 만족하는 지갑을 만들기 위해 디자인팀은 모든 명함의 가로 길이와 세로 길이를 조사했습니다.

    ------------------------------------
    | 명함번호  |  가로 길이  |  세로 길이  |
    ------------------------------------
    |  1      |   60       |  50       |
    ------------------------------------
    |  2      |   30       |  70       |
    ------------------------------------
    |  3      |   60       |  30       |
    ------------------------------------
    |  4      |   80       |  40       |
    ------------------------------------

    가장 긴 가로 길이와 세로 길이가 각각 80, 70이기 때문에 80(가로) x 70(세로) 크기의 지갑을 만들면 모든 명함들을 수납할 수 있습니다.
    하지만 2번 명함을 가로로 눕혀 수납한다면 80(가로) x 50(세로) 크기의 지갑으로 모든 명함들을 수납할 수 있습니다.
    이때의 지갑 크기는 4000(=80 x 50)입니다.
    모든 명함의 가로 길이와 세로 길이를 나타내는 2차원 배열 sizes 가 매개변수로 주어집니다.
    모든 명함을 수납할 수 있는 가장 작은 지갑을 만들 때, 지갑의 크기를 return 하도록 solution 함수를 완성해주세요.

    제한사항

    sizes 의 길이는 1 이상 10,000 이하입니다.
    sizes 의 원소는 [w, h] 형식입니다.
    w는 명함의 가로 길이를 나타냅니다.
    h는 명함의 세로 길이를 나타냅니다.
    w와 h는 1 이상 1,000 이하인 자연수입니다.

     */

    private static int solution(int[][] sizes) {

        int width = 0;
        int height = 0;

        // 이차원 배열의 각 행을 순환
        for (int i = 0; i < sizes.length; i++){

            // 각 행을 0 번 인덱스를 작은 값 ( width )으로 1번 인덱스를 큰 값 ( height )로 정렬해준다.
            // 정렬한 후, width 와 height 의 각 최댓값을 구해주면 모두 담을 수 있는 명함의 크기가 나온다.
            width = Math.max(Math.min(sizes[i][0], sizes[i][1]), width);
            height = Math.max(Math.max(sizes[i][0], sizes[i][1]), height);

        }

        return width * height;
    }

    // 타인 풀이  - p*******3 , 최*근 : solution ( 나의 풀이 ) 와 동일한 로직을 가지고 있으나 가독성이 더 뛰어남
    private static int solution2(int[][] sizes) {

        int max = 0;
        int min = 0;

        // 이차원 배열을 순환
        for (int[] size : sizes) {

            // 각각의 행에 대해 최소값 최대값을 변수에 담아준다.
            int paramMax = Math.max(size[0], size[1]);
            int paramMin = Math.min(size[0], size[1]);

            if (paramMax > max) { // 각 행의 값과 반복문 밖에 있는 변수와 비교해서 최댓값을 갱신
                max = paramMax;
            }

            if (paramMin > min) { // 최대값과 같은 방법으로 최솟값을 갱신
                min = paramMin;
            }
        }
        return max * min;
    }

}
